import { promises as fs } from 'fs';

import ImgLoaderOptions from '../types/ImgLoaderOptions';
import deriveExportOptions from './deriveExportOptions';
import getDefaultQuality from './getDefaultQuality';


const base = `
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT.
// TO UPDATE, SET THE generateDeclarations OPTION OF @bsmth/img-loader TO true
// AND RUN WEBPACK ONCE IN DEVELOPMENT MODE.


type _BismuthImage = {
	/** URL of the compressed/resized image. */
	src: string;
	/** Width of the compressed/resized image in pixels. */
	width: number;
	/** Height of the compressed/resized image in pixels. */
	height: number;
};

type _WithMeta = {
	/** Equivalent to \`__webpack_public_path__\` */
	prefix: string;
	/** Whether the image contains transparent areas. */
	alpha: boolean;
	/** Aspect ratio of the __source image__. */
	aspect: number;
}

type _WithWebp = {
	/** URL of the WebP version. */
	webp: string;
};

type _WithBasis = {
	/** URL of the basis version. */
	basis: string;
};

type _WithThumbnail = {
	thumbnail: {
		/** Thumbnail data: either a base64 encoded PNG or the base64 encoded raw RGBA data. */
		data: string;
		/** Thumbnail width in pixels. */
		width: number;
		/** Thumbnail height in pixels. */
		height: number;
	};
};

type BismuthImage =
	_BismuthImage
	& _WithMeta
	& Partial<_WithWebp>
	& Partial<_WithBasis>
	& Partial<_WithThumbnail>
	& {
		/** Resized variants of this image. */
		sizes: Record<string, Partial<_BismuthImage & _WithWebp & _WithBasis>>;
	};

`;


const exts = [
	'*.jpg',
	'*.jpeg',
	'*.png',
	'*.gif',
	'*.svg',
];


function declaration({
	options,
	ext,
	mode = '',
	quality = '',
}: {
	options: ImgLoaderOptions;
	ext: string;
	mode?: string;
	quality?: string;
}) {
	const qualityName = quality || getDefaultQuality( options, mode || 'default' );
	const exportOptions = deriveExportOptions({
		options,
		mode: mode || 'default',
		quality: qualityName,
	});

	const types: string[] = ['_BismuthImage', '_WithMeta'];
	const sizeTypes: string[] = ['_BismuthImage'];

	if ( exportOptions.thumbnail ) {
		types.push( '_WithThumbnail' );
	}
	if ( exportOptions.emitWebp ) {
		types.push( '_WithWebp' );
		sizeTypes.push( '_WithWebp' );
	}
	if ( exportOptions.emitBasis ) {
		types.push( '_WithBasis' );
		sizeTypes.push( '_WithBasis' );
	}

	const sizes = Object.keys( exportOptions.sizes ).filter( s => s !== 'default' );

	const params = [];
	if ( mode ) params.push( `mode=${mode}` );
	if ( quality ) params.push( `quality=${quality}` );


	const modeWarning = ( subject: string, indent = 1 ) => {
		if ( mode ) return '';

		const newline = `\n${'\t'.repeat( indent )} * `;
		// eslint-disable-next-line prefer-template
		return newline
			+ `*Note that due to current TS limitations, ${subject} might be `
			+ 'incorrect here if you\'re using a `test` function to set `mode`.*'
			+ newline
			+ newline
			+ '*To get correct types, set `mode` manually as a query parameter.*';
	};


	return `
declare module '${ext}${params.length > 0 ? `?${params.join( '&' )}` : ''}' {
	/**
	 * Image processed by \`@bsmth/img-loader\`
	 *
	 *		mode = "${mode || 'default'}"
	 *		quality = "${qualityName}"
	 *		sizes = ${JSON.stringify( sizes )}
	 * ${modeWarning( '`mode` and `sizes`' )}
	 */
	const e: ${types.join( ' & ' )} & {
		/**
		 * Named, resized variants of this image.
		 *
		 * In this case ${
	sizes.length > 0
		? `available: \`${sizes.join( '`, `' )}\``
		: 'none are available.'
}
		 * ${modeWarning( 'available sizes', 2 )}
		 */
		sizes: ${
	sizes.length > 0
		? `Record<'${sizes.join( "' | '" )}', ${sizeTypes.join( ' & ' )}>`
		: '{}'
};
	};
	export default e;
}
`;
}


export default function generateDeclarations( options: ImgLoaderOptions ): void {
	const modes = Object.keys( options.modes );
	const qualityLevels = Object.keys( options.qualityLevels );

	let output = `${base}`;

	exts.forEach( ext => {
		output += declaration({
			options,
			ext,
		});

		qualityLevels.forEach( quality => {
			output += declaration({
				options,
				ext,
				quality,
			});
		});

		modes.forEach( mode => {
			output += declaration({
				options,
				ext,
				mode,
			});

			qualityLevels.forEach( quality => {
				output += declaration({
					options,
					ext,
					mode,
					quality,
				});
			});
		});
	});

	fs.writeFile( 'img-imports.d.ts', output );
}
